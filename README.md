# ФИТ НГУ 5 семестр (3 курс) 2023/2024 учебный год
## Лабораторные работы по сетям и телекоммуникациям
В данном репозитории содержатся все лабораторные работы, написанные по данному курсу. Нумерация соовпадает с лекторской:

1. (first) - обнаружение копий себя в локальной сети
2. (second) - передача файлов по TCP с подсчётом скорости
3. (third) - места (асинхронное сетевое взаимодействие)
4. (fourth) - змейка по сети
5. (fifth) - SOCKS-прокси

Подробнее о технологиях ниже:
## Обнаружение копий себя в локальной сети
### Язык программирования
Golang v 1.21

### Используемые библиотеки
- ***fyne.io*** - самый популярный кроссплатформенный GUI фреймворк для golang, выполненный в дизайне material, использовался для ввода пользовательских данных и отображения списка копий программы.
- ***golang.org/x/net*** - расширенная библиотека для работы с сетью, упрощает взаимодействие с сетью (в частности с multicast).

### Способ запуска
Считается, что пользователь уже находится в директории `first`:

1. `go run .` - для быстрого запуска приложения.
2. Для получения исполняемого файла:
    - `mkdir build` - создать поддиректорию build в текущей директории.
    - `go build -o build/copy-finder` - собрать проект в исполняемый файл с названием `copy-finder` в директории `build`.
    - `build/copy-finder` - запустить исполняемый файл

### Использование
После запуска приложения перед пользователем появится основной интерфейс приложения, адаптированный под текущую цветовую схему операционной системы.
Главный экран состоит из 4-х секций:

1. Ввод прозвища/псевдонима пользователя (nickname) - может быть пустым.
2. IPv4 адрес, на котором программа хочет обнаруживать свои копии. Так как первые 3 числа адреса строго фиксированы в соответствии с условием задачи (обнаружение копий в *локальной сети*), пользователю для выбора доступно только 254 возможные сети для обнаружения копий, определяемые как раз последним числом (0 и 255 - зарезервированы). В случае ввода правильных значений кнопка "Watch IP4" станет доступной.
3. IPv6 адрес, на котором программа хочет обнаруживать свои копии. По аналогии с IPv4, доступен сильно ограниченый диапазон адресов. При вводе корректных значений для последних двух полей адреса, кнопка "Watch IP16" станет доступна.
4. Три кнопки: настройки ("settings"), "Watch IP4" и "Watch IP16".

В настройках доступен выбор размера шрифта, акцентного цветa приложения, включение и выключение анимации виджетов, и выбор темной или светлой темы.

Если пользователь указал корректные данные, то после нажатия доступной кнопки, пользователя перебросит на экран со списком текущих копий в этой сети. Пользователь так же будет видеть сам себя в списке и свой IP-адрес. Раз в 3 секунды приложение отправляет сообщение на указанный multicast-адрес ***(стоит удостовериться, что и firewall, и сама сеть разрешают multicast-пакеты в данной сети и на данном интерфейсе)***. Также приложение слушает все пакеты на этом же multicast-адресе. Если новых сообщений от копии не поступало на протяжении 10 секунд, то копия считается потерянной, и она пропадает из списка.

## Передача файла по TCP с подсчетом скорости
### Язык программирования
Java (JDK 17)
### Используемые библиотеки
- ***Google Guava*** - набор контейнеров и утилит, упрощающий разработку отдельных компонентов (в данном случае использовалась утилита конвертации чисел в их байтовое представление для передачи по сети)

### Способ запуска
Считается, что пользователь уже находится в директории `second`:
1. В зависимости от того, что нужно пользователю - клиент или сервер, нужно зайти в соответствующую директорию:
    - `cd Server` для сервера, либо
    - `cd Client` для клиента
2. `./gradlew jar` - создание `jar`-архива с приложением
3. `cd app/build/libs` - переход в директорию с собранным `jar`-архивом
4. `java -jar app.jar` - запуск приложения

### Использование
И сервер, и клиент представляют собой консольные приложения.
#### Сервер
После запуска сервера перед пользователем появится информация о разработчике в 4-х строчках. Пользователю потребуется ввести порт, на котором сервер будет слушать входящие соединения. Когда порт будет введен, сервер начнет слушать входящие соединения, выводя каждые 3 секунды информацию о текущей скорости скачивания. Скачанные файлы будут появляться в той же директории, из которой был загружен сервер.
#### Клиент
После запуска клиент попросит указать путь до файла, который будет отправлен на сервер по TCP. После этого, сервер попросит адрес сервера **без указания порта**. После ввода адреса, клиент попросит указать порт, на котором сервер слушает входящие соединения. После указания порта начнется передача файла на сервер.
## Места (асинхронное взаимодействие)
### Язык программирования
Golang v 1.21
### Используемые библиотеки

- ***[websocket](github.com/gorilla/websocket)*** - библиотека для работы с websocket в go
- ***golang.org/x/crypto*** - библиотека для быстрого подключения TLS.

### Способ запуска
Предполагается, что пользователь находится в директории `third`.

Зайдем в директорию с проектом:

`cd places`

Для запуска приложения нужно сначала получить *API-ключи* следующих сервисов:

- [graphhopper](graphhopper.com)
- [openweathermap](openweathermap.org)
- [opentripmap](opentripmap.com)

После получения ключей нужно открыть файл `main.go` и отредактировать там переменные `gKey` (graphhopperKey), `wKey` (weatherKey), `tKey` (tripKey), то есть вставить туда свои ключи (в идеале ключи должны задаваться другим путем).
Если пользователь хочет подключить сертификат для работы *https*, то пользователю надо раскомментировать строки, помеченные в исходниках. Так же потребуется исправить файл `site/common/backend_web_socket.ts`.

После этих действий, пользователь должен скомпилировать TypeScript в JavaScript:

1. `cd site`
2. `ts .`

Так же нужно перевести SCSS файлы в CSS:

1. `cd site`
2. `npx node-sass .`

После этих действий можно запускать сервер:

`go run .`

После скачивания зависимостей и сборки проекта, сервер без сообщений о запуске начнет слушать входящие сообщения. Для того, чтобы получить доступ к приложению, нужно в браузере сделать запрос на сервер. По умолчанию это `http://localhost:6969` (в случае HTTPS стоит не забыть про смену порта и доменного имени). Во время загрузки сайта в консоль сервера выведутся запрошенные браузером сайты.

Сервер на Golang выступает не только как сервис асинхронных запросов, но и как веб-сервер.
### Использование
После загрузки страницы перед пользователем появится поле для ввода места, которое ему интересно. Снизу будет отображаться список мест с совпавшим названием. Еще ниже можно обнаружить интерактивную 3D карту, ***которая может не отображаться, если ваш браузер не поддерживает библиотеку mapgl (например, mapgl не поддерживается браузером LibreWolf)***.

После ввода интересного места, с сайта отправится соответствующий запрос на backend, который асинхронно выполняет запросы в сервисы. В результате после поиска у пользователя появится список совпадающих по названию мест. Пользователь должен выбрать интересующее его место. После выбора места, интерактивная карта отметит выбранное пользователем место и отметит все интересные места вокруге, чуть ниже карты расположится погода в выбранном месте, а еще ниже можно обнаружить список интересных мест поблизости. Если выбрать элемент из этого списка, то можно увидеть подробную информацию об этом месте, а также связанную с этим местом фотографию.

## Змейка по сети
### Язык программирования
Kotlin v 1.9.20
### Используемые библиотеки
 - ***Javax Swing*** - самая популярная библиотека GUI для JVM. Использовалась для отрисовки змейки, ввода пользовательских данных, отображения статистики, показа доступных игр.
 - ***[protobuf-kotlin](https://mvnrepository.com/artifact/com.google.protobuf/protobuf-kotlin/3.24.4)*** - библиотека для сериализации и десериализации kotlin в protobuf
 - ***[kotlinx-coroutines](https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-coroutines-core/1.7.3)*** - библиотека для работы с корутинами (User-space потоками) в kotlin.
 - ***[kotlinx-coroutines-swing](https://mvnrepository.com/artifact/org.jetbrains.kotlinx/kotlinx-coroutines-swing/1.7.3)*** - поддержка kotlinx-coroutines для библиотеки Swing.
 - ***[ktor](https://mvnrepository.com/artifact/io.ktor/ktor-network-jvm/2.3.5)*** - библиотека для асинхронной работы с сетью в kotlin, так как по умолчанию в kotlin нет встроенного способа общения с сетью (насколько понял я, для этого нужны java библиотеки), поддерживает kotlin-coroutines.
 - ***Arrow [1](https://mvnrepository.com/artifact/io.arrow-kt/arrow-core/1.2.0) и [2](https://mvnrepository.com/artifact/io.arrow-kt/arrow-fx-coroutines/1.2.0)*** - библиотеки для расширения функционального программирования в kotlin (например, функциональная обработка ошибок, которая и была использована)

### Способ запуска
Предполагается, что пользователь уже находится в директории `fourth`

`cd OnlineSnake` - зайти в директорию проекта

Нужно удостовериться, что у вас стоит [protobuf](https://protobuf.dev/).

1. `./gradlew run` - для запуска проекта с помощью gradle.
2. Для сборки приложения в `jar`-файл:
    - `./gradlew jar` - собирает приложение в `jar`-файл
    - `java -jar build/libs/OnlineSnake-1.0-SNAPSHOT.jar` - для запуска собранного в `jar`-архив приложения.

### Использование
После запуска перед пользователем откроется окно приложения. Тут пользователь может ввести корректные параметры поля (некорректные параметры сделают кнопку начала игры неактивной, а некорректно введенные поля подсветят красным), свой nickname, а также название сервера, к которому смогут подключаться другие игроки. Если все параметры введены правильно, то у пользователя станет доступна кнопка "New". При нажатии этой кнопки у пользователя начнется игра: его змейка разместится на поле (также как и еда), а его игру смогут увидеть остальные игроки. Так же у пользователя есть список доступных игр, к которым он может присоединиться. Для этого ему просто надо выбрать игру к которой он хочет присоединиться (желательно при этом указав свой nickname, хоть это и не обязательно).
### Особенности
Все общение происходит через два UDP сокета: первый отвечает за прием multicast сообщений (анонс доступных игр или запрос на доступные игры), второй отвечает за все остальное - отправку анонс сообщений, обмен информацией между клиентами, переотправка и подтверждение сообщений. Так как у данной игры по условию нет какого-то центрального сервера, то приложеняи должны уметь динамически подстраиваться под роли: master (владелец игры), deputy (заместитель), normal (обычный игрок), viewer (наблюдатель). После того, как master змейка "умрет", стать master'ом должен узел с ролью deputy, а после становления master он должен найти себе нового deputy, а после становления master он должен найти себе нового deputy. Подробнее об этом можно почитать в условиях лабораторных работ в этом же репозитории.

Все общение происходит поверх модели protobuf.

Все сообщения отправляются разным клиентам параллельно, и в случае отсутствия подтверждения этих сообщений, они переотправляются. Если подтверждения сообщения нет на протяжении долгого времени, то не отвечающий узел считается потерянным.

## SOCKS-proxy
### Язык программирования
Golang v 1.21
### Используемые библиотеки
Нет
### Способ запуска
Считается, что пользователь уже находится в директории `fifth`:

`cd socks5proxy` - зайти в директорию проекта

1. `go run .` - для быстрого запуска приложения.
2. Для получения исполняемого файла:
    - `mkdir build` - создать директорию `build` в текущей директории.
    - `go build -o build/proxy` - собрать проект в исполняемый файл с названием `proxy` с размещением в директории `build`
    - `build/proxy` - запустить исполняемый файл

### Использование
После запуска приложения перед пользователем появится надпись о том, что он запускает SOCKS-proxy, Ниже покажется информация о разработчике. Дальше приложение попросит пользователя ввести порт. После ввода порта приложение начнет свою работу. Остается просто подключиться к proxy *(при подключении стоит указать режим без авторизации)* и можно пользоваться! Каждое соединение обрабатывается в отдельной горутине. Полная остановка сервера реализована, но делается это асинхронно (то есть выход из функции Close() происходит раньше, чем остановка всех соединений) (можно заменить на wait pool). Если после ввода порта ввести любую строку в консоль, где приложение запущено, то в течение 15 секунд прокси остановится. Также прокси собирает некоторую информацию о соединениях, но по-умолчанию ничего не выводит. Также нет "рычага" включения и красивого вывода всей статистики. По замерам, proxy способен вытянуть видео на YouTube в разрешении 8k на одном устройстве. Тесты с большим количеством устройств провести не удалось, так как был произведен упор в скорость провайдера интернета. При просмотре нескольких видео в меньшем разрешении проблем не наблюдалось.
